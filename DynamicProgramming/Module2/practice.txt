class Solution {
public:
    int superEggDrop(int k, int n) 
    {
      
        /*This line creates a 2D table dp where dp[i][j] represents the minimum number of moves needed to determine the value of f with i eggs and j moves. 
        The table is initialized with k+1 rows and n+1 columns, where k and n are the number of eggs and floors, respectively.*/
        vector<vector<int>> dp(k+1, vector<int>(n+1));
        //This loop initializes the base case for the table, which is that it takes 1 move to check the first floor with any number of eggs.
        for (int i = 1; i <= k; i++) {
            dp[i][1] = 1;
        }

       //This loop initializes the base case for the table, which is that it takes j moves to check j floors with 1 egg.
         for (int j = 1; j <= n; j++) {
            dp[1][j] = j;
        }

        // These nested loops fill the table using the formula mentioned earlier, which is:
        // dp[i][j] = 1 + min(max(dp[i-1][k-1], dp[i][j-k]))
        // where k goes from 1 to j.
        // The inner loop uses binary search to find the value of k that minimizes the maximum of dp[i-1][k-1] and dp[i][j-k]. The value of dp[i][j] is then set to 1 + the minimum value of dp[i-1][k-1].
        for (int i = 2; i <= k; i++) {
            for (int j = 2; j <= n; j++) {
                int left = 1, right = j;
                while (left < right) {
                    int mid = left + (right - left) / 2;
                    if (dp[i-1][mid-1] < dp[i][j-mid]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                dp[i][j] = 1 + dp[i-1][left-1];
            }
        }
        
        //This line returns the value of dp[k][n] as the result, which is the minimum number of moves needed to determine the value of f with k eggs and n floors.
        return dp[k][n];
    }
};